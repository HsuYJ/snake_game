var et=Object.defineProperty,st=Object.defineProperties;var nt=Object.getOwnPropertyDescriptors;var L=Object.getOwnPropertySymbols;var ot=Object.prototype.hasOwnProperty,it=Object.prototype.propertyIsEnumerable;var V=(a,t,e)=>t in a?et(a,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[t]=e,K=(a,t)=>{for(var e in t||(t={}))ot.call(t,e)&&V(a,e,t[e]);if(L)for(var e of L(t))it.call(t,e)&&V(a,e,t[e]);return a},Y=(a,t)=>st(a,nt(t));var u=(a,t,e)=>(V(a,typeof t!="symbol"?t+"":t,e),e),z=(a,t,e)=>{if(!t.has(a))throw TypeError("Cannot "+e)};var h=(a,t,e)=>(z(a,t,"read from private field"),e?e.call(a):t.get(a)),y=(a,t,e)=>{if(t.has(a))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(a):t.set(a,e)},E=(a,t,e,n)=>(z(a,t,"write to private field"),n?n.call(a,e):t.set(a,e),e);var I=(a,t,e)=>(z(a,t,"access private method"),e);const at=function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&n(i)}).observe(document,{childList:!0,subtree:!0});function e(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerpolicy&&(o.referrerPolicy=s.referrerpolicy),s.crossorigin==="use-credentials"?o.credentials="include":s.crossorigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function n(s){if(s.ep)return;s.ep=!0;const o=e(s);fetch(s.href,o)}};at();var l={SNAKE_BODY:"SNAKE_BODY",STONE:"STONE",FRUIT:"FRUIT"},g={INIT:"INIT",START:"START",PAUSE:"PAUSE",RESUME:"RESUME",DROP_FRUIT:"DROP_FRUIT",SNAKE_MOVE:"SNAKE_MOVE",UPDATE:"UPDATE",EAT:"EAT",GAME_OVER:"GAME_OVER"};const rt=["x","y"];let ct=0;class ${constructor(){u(this,"type","gameObj");u(this,"id",`gb${ct+=1}`);u(this,"position",{x:0,y:0})}static create(t={}){const{position:e}=t,n=new this;return e&&(n.position=e),n}getInfo(){return K({id:this.id,type:this.type},this.position)}move(t){const{position:e}=this;rt.forEach(n=>{e[n]+=t[n]})}moveTo(t){const{x:e,y:n}=t;this.position={x:e,y:n}}}class j extends ${constructor(){super(...arguments);u(this,"type",l.SNAKE_BODY)}}class lt extends ${constructor(){super(...arguments);u(this,"type",l.STONE)}}class Q extends ${constructor(){super(...arguments);u(this,"type",l.FRUIT)}}var dt={[l.SNAKE_BODY]:j,[l.STONE]:lt,[l.FRUIT]:Q},S={UP:[0,-1],RIGHT:[1,0],DOWN:[0,1],LEFT:[-1,0]};class ht{constructor(){u(this,"body",[]);u(this,"nextDirection",S.UP);u(this,"direction",S.UP);u(this,"isFruitEaten",!1)}static create(t={}){const{position:{x:e,y:n},size:s=3}=t,o=new this;return o.body=Array.from({length:s},(i,r)=>j.create({position:{x:e,y:n+r}})),o}getInfo(){return this.body.map(t=>t.getInfo())}setDirection(t){const[e,n]=t,{direction:[s,o]}=this;(e!==0&&parseInt(e+s,10)!==0||n!==0&&parseInt(n+o,10)!==0)&&(this.nextDirection=t)}eatFruit(){this.isFruitEaten=!0}move(){const{body:t,nextDirection:e,isFruitEaten:n}=this,[s,o]=e,i=t[0],r=t.length;if(this.direction=e,n){const c=j.create({position:t[r-1].position});this.isFruitEaten=!1,t.push(c)}for(let c=r-1;c>0;c-=1){const m=t[c],d=t[c-1];m.moveTo(d.position)}i.move({x:s,y:o})}move2(){const{body:t,nextDirection:e,isFruitEaten:n}=this,[s,o]=e,{position:i}=t[0],r=t[t.length-1],c=n?j.create({position:r.position}):t.pop();this.isFruitEaten=!1,this.direction=e,c.moveTo({x:i.x+s,y:i.y+o}),t.unshift(c)}}class ut{constructor(){u(this,"gameObjs",[]);u(this,"snake",null);u(this,"size",{width:10,height:10})}static create(t){const{width:e,height:n,gameObjs:s}=t,o=new this;return o.size={width:e,height:n},o.gameObjs=s.map(({type:i,x:r,y:c})=>dt[i].create({position:{x:r,y:c}})),o.snake=ht.create({position:{x:Math.round(e/2),y:Math.round(n/2)},size:5}),o}removeGameObj(t){const{gameObjs:e}=this,n=e.findIndex(s=>s.id===t);e.splice(n,0)}dropFruit(){const{size:{width:t,height:e},gameObjs:n,snake:s}=this,o=Array.from({length:t},(p,f)=>Array.from({length:e},(U,tt)=>`${f},${tt}`)).flat(),i=n.concat(s.body).map(({position:{x:p,y:f}})=>`${p},${f}`),r=o.filter(p=>!i.includes(p)),[c,m]=r[Math.floor(r.length*Math.random())].split(","),d=Q.create({position:{x:+c,y:+m}});return n.push(d),d}getInfo(){return Y(K({},this.size),{gameObjs:this.gameObjs.map(t=>t.getInfo())})}}var M,A,H,N,_,pt,G,ft,D,B,k,R,F,q;class mt{constructor(){y(this,A);y(this,_);y(this,G);y(this,F);u(this,"eventCallbacks",{[g.INIT]:new Set,[g.SNAKE_MOVE]:new Set,[g.UPDATE]:new Set,[g.DROP_FRUIT]:new Set,[g.GAME_OVER]:new Set});y(this,M,null);y(this,N,0);u(this,"playing",!1);y(this,D,!1);y(this,B,.2);y(this,k,Date.now());y(this,R,0)}static create(){return new this}setup(t){const e=ut.create(t);this.gameMap=e;const n=g.INIT,s=this.eventCallbacks[n],o=e.snake.getInfo();s.forEach(i=>{i({eventName:n,data:{snake:o,gameMap:e.getInfo()}})})}start(){this.playing=!0,I(this,A,H).call(this),E(this,k,Date.now()),I(this,F,q).call(this)}setDirection(t){this.gameMap.snake.setDirection(t)}on(t,e,n){const s=this.eventCallbacks[t];let o=e;const i=()=>{s.delete(o)};return n!=null&&n.once&&(o=(...r)=>{i(),e(...r)}),s.add(o),i}}M=new WeakMap,A=new WeakSet,H=function(){const t=this.gameMap.dropFruit();E(this,M,t);const e=g.DROP_FRUIT;this.eventCallbacks[e].forEach(s=>{s({eventName:e,data:{fruit:t.getInfo()}})})},N=new WeakMap,_=new WeakSet,pt=function(){const{gameMap:t}=this,[{position:e}]=t.snake.body,n=h(this,M),{position:s}=n;return e.x===s.x&&e.y===s.y?n:null},G=new WeakSet,ft=function(){const{gameMap:t}=this,{width:e,height:n,gameObjs:s}=t.getInfo(),[o,...i]=t.snake.getInfo(),{x:r,y:c}=o,d=s.concat(i).filter(({type:f})=>f!==l.FRUIT).some(f=>f.x===r&&f.y===c);return d||r<0||r>=e||c<0||c>=n},D=new WeakMap,B=new WeakMap,k=new WeakMap,R=new WeakMap,F=new WeakSet,q=function(){if(h(this,D)){const p=g.GAME_OVER,f=this.eventCallbacks[p],x=h(this,N);f.forEach(U=>{U({eventName:p,data:{score:x}})});return}requestAnimationFrame(()=>I(this,F,q).call(this));const t=Date.now(),e=t-h(this,k);if(E(this,k,t),E(this,R,h(this,R)-e),h(this,R)>0)return;const n=h(this,B);E(this,R,h(this,R)+1e3*n);const{gameMap:s}=this,{snake:o}=s;o.move(),I(this,G,ft).call(this)&&E(this,D,!0);const r=I(this,_,pt).call(this);r&&(s.removeGameObj(r),o.eatFruit(r),E(this,N,h(this,N)+1),I(this,A,H).call(this));const c=g.SNAKE_MOVE,m=this.eventCallbacks[c],d=h(this,N);m.forEach(p=>{p({eventName:c,data:{updateInterval:n,gameMap:s.getInfo(),body:o.getInfo(),eatenFruit:r,score:d}})})};const X=(()=>{const a=new Set;let t=Date.now();function e(){requestAnimationFrame(e);const s=Date.now(),o=s-t;t=s,a.forEach(i=>{const r=i;r.elapsedTime+=o;const{value:c,targetValue:m,deltaValue:d,totalTime:p,elapsedTime:f}=r,x=f>=p,U=x?m:c+d*(f/p);r.target[r.valueKey]=U,x&&a.delete(i)})}function n(s,o,i,r){const c=s[o],m=i-c,d=r*1e3;a.add({target:s,valueKey:o,value:c,targetValue:i,deltaValue:m,totalTime:d,elapsedTime:0})}return e(),n})();function yt(a,t,e,n){const s=n||document.createElement("canvas");return s.width=e*a,s.height=e*t,s.style.cssText=`
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    background-color: white;
  `,s.parentNode||document.body.appendChild(s),s}var T,P,C;class Z{constructor(){y(this,T,new Map);y(this,P,Date.now());y(this,C,0)}setup(t={}){const{width:e,height:n,blockSize:s=10,rootCanvas:o}=t,i=yt(e,n,s,o),r=i.cloneNode();this.canvas=i,this.shadowCanvas=r,this.width=e,this.height=n,this.blockSize=s,this.render=this.render.bind(this);const c=r.getContext("2d");c.fillStyle="white",c.fillRect(0,0,i.width,i.height)}add(t){const{x:e,y:n,id:s=`${e}, ${n}`}=t;return h(this,T).set(s,t),s}removeById(t){h(this,T).delete(t)}removeByPosition(t,e){h(this,T).delete(`${t},${e}`)}moveTo(t,e,n,s){const i=h(this,T).get(t);return i&&(X(i,"x",e,s),X(i,"y",n,s)),!!i}render(){requestAnimationFrame(this.render);const t=Date.now(),e=t-h(this,P);if(E(this,P,t),E(this,C,h(this,C)-e),h(this,C)>0)return;E(this,C,h(this,C)+1e3/60);const{canvas:n,shadowCanvas:s,blockSize:o}=this,{width:i,height:r}=s,c=h(this,T),m=n.getContext("2d"),d=s.getContext("2d");d.clearRect(0,0,i,r),m.clearRect(0,0,i,r),c.forEach(({x:p,y:f,color:x})=>{d.save(),d.fillStyle=x,d.translate(o*p,o*f),d.fillRect(0,0,o,o),d.restore()}),m.drawImage(s,0,0,i,r)}startRender(){this.render()}}T=new WeakMap,P=new WeakMap,C=new WeakMap;const W={name:"World 1-1",author:"Rex",width:20,height:20,gameObjs:[{type:l.STONE,x:2,y:3},{type:l.STONE,x:2,y:4},{type:l.STONE,x:2,y:5},{type:l.STONE,x:3,y:5},{type:l.STONE,x:4,y:5},{type:l.STONE,x:5,y:5},{type:l.STONE,x:12,y:13},{type:l.STONE,x:12,y:14},{type:l.STONE,x:12,y:15},{type:l.STONE,x:13,y:15},{type:l.STONE,x:14,y:15},{type:l.STONE,x:15,y:15}]},w=mt.create(),J=parseInt(Math.min((window.innerWidth-20)/W.width,(window.innerHeight-20)/W.height),10),O={[l.SNAKE_BODY]:"green",[l.STONE]:"gray",[l.FRUIT]:"orange"},v=new Z,b=new Z;w.on(g.INIT,a=>{console.log(a);const{data:{snake:t,gameMap:{width:e,height:n,gameObjs:s}}}=a;v.setup({width:e,height:n,blockSize:J,rootCanvas:document.getElementById("playGround")}),s.forEach(({id:o,x:i,y:r,type:c})=>{v.add({id:o,x:i,y:r,color:O[c]})}),t.forEach(({id:o,x:i,y:r,type:c})=>{v.add({id:o,x:i,y:r,color:O[c]})}),v.startRender(),b.setup({width:e,height:n,blockSize:J*.2,rootCanvas:document.getElementById("smallMap")}),s.forEach(({id:o,x:i,y:r,type:c})=>{b.add({id:o,x:i,y:r,color:O[c]})}),t.forEach(({id:o,x:i,y:r,type:c})=>{b.add({id:o,x:i,y:r,color:O[c]})}),b.startRender()},{once:!0});w.on(g.SNAKE_MOVE,a=>{const{data:{gameMap:{gameObjs:t},updateInterval:e,body:n,eatenFruit:s}}=a;n.forEach(({id:o,x:i,y:r,type:c})=>{v.moveTo(o,i,r,e)||v.add({id:o,x:i,y:r,color:O[c]}),b.removeById(o),b.add({id:o,x:i,y:r,color:O[c]})}),s&&(v.removeById(s.id),b.removeById(s.id))});w.on(g.DROP_FRUIT,a=>{const{data:{fruit:{id:t,type:e,x:n,y:s}}}=a;v.add({id:t,x:n,y:s,color:O[e]}),b.add({id:t,x:n,y:s,color:O[e]})});w.on(g.GAME_OVER,()=>{window.setTimeout(()=>{window.confirm("GAME OVER")},1e3*.5)});w.setup(W);document.onkeydown=a=>{if(a.isComposing)return;w.playing||w.start();let t=S.UP;switch(a.key){case"w":t=S.UP;break;case"d":t=S.RIGHT;break;case"s":t=S.DOWN;break;case"a":t=S.LEFT;break}w.setDirection(t)};
